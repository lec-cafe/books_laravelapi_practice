# アプリケーションの設計

## アプリケーションの設計

アプリケーションを開発する上で、
特定の機能をクラスに分割してモジュール化することは、非常に重要な設計のポイントです。

開発の進行に伴って日々膨大に膨らんでいくコードを、
適切なサイズで **分割し**、**再利用可能な状態**にすることをモジュール化といいます。

モジュール化には、様々な設計の観点が重要となっており、
どのようなサイズで分割するか、どのような再利用性を担保するかなど、
適切な方法を考えなければなりません。

無作為に大量のクラスを生成してしまうと、大量のクラス同士で生まれる依存関係はとても複雑になり、
システム設計の全容を把握するのがとても困難になります。

アプリケーションの分割を考える上でいくつかの重要な観点がありますので、
まずは一般的なアプリケーション設計の考え方を確認してみましょう。

## Model View Controller

Model View Controller(MVC) パターンは、
古くから言われるアプリケーション構築の一般的なパターンです。

MVC パターンでは アプリケーションの主要な処理を、
以下の 3つに分割し、アプリケーション分割に重要な視点を与えてくれます。

- Model : アプリケーション内のデータ処理に関する部分
- Controller : アプリケーションにおける入力、制御に関する部分
- View : アプリケーションの振る舞いに関する部分

Laravel を利用した一般的な MPA では、
Controller 部分を Laravel の Controller が、
View 部分を Blade が担当します。

REST API の開発に置いても、
Controller 部分は Route が相当し、 View 部分は Response に関する処理が、
その担当を担います。

基本的な MVC 構成のアプリケーション分割は、
フレームワークの機能を利用することで、簡単に分割することが可能となっているため、
開発者は単純に ルートで記述される処理を、 Model と View に分けながら、
Controller の外に定義するだけで、簡単に MVC を実現することができます。

### Fat Controller 

Controller 内に多数の処理が記載される状況は、一般的に Fat Controller と呼ばれます。

ルートの起点であるコントローラは、ルートの処理を後から読み解くための開始地点でもあり、
可能な限りシンプルで明瞭に処理が記述されているべきです。

Controller の内部のコードが膨大に膨らんでいる場合、
それらの処理を、適切にコード分割して、外部化する必要があるでしょう。

### Skinny Controller

Fat Controller を改善し、Controller 内の処理が適切に外部化された状態を、
Skinny Controller と呼びます。

しかしながら、コントローラで行われるべき処理が、
全て別のクラスに定義されただけでは、かえってController 内のコードを理解するために読むべきコードが
他のファイルに分散するだけで、コードの可読性が低下するのみとなります。

Skinny Controller を目指す上で以下のようなコードは Controller 層に残しておくのが適切でしょう。

- リクエストパラメータの取得に関する処理
- バリデーションに関する処理
- 振る舞いに影響するようなエラーハンドリングや処理に関する振り分けのロジック

ルートのパラメータやバリデーションに関する処理は、
ルートが固有に持つもので、そのような情報はモデル層に引き渡す必要もなく、
Controller の内部で処理するのが良いでしょう。

また、ルートのパラメータなどの条件に応じて、
処理すべき内容やコールすべきロジック、View の処理が異なる場合の分岐も、
Controller 内で明記されている方が、あとからコードを読み解くために必要な情報を明確に提供できるでしょう。

## レイヤードアーキテクチャ

MVC よりもより実践的なアプリケーション設計のアプローチとして、
レイヤードアーキテクチャと呼ばれるものがあります。

レイヤードアーキテクチャは、システムが持つ業務知識を **ドメイン** と呼び、
ドメインに関する処理と、それ以外とを区別するための設計フローです。

一般的には、以下の ４層の形で理解されるケースが多いでしょう。

- Presentation : UI に関するロジック ( 画面/Viewなど )
- Application : アプリケーション制御に関するロジック
- Domain : 機能仕様・業務知識に関するロジック
- Infrastructure : DB や 外部APIなどデータストアに関するロジック

レイヤードアーキテクチャでは、依存の方向性を
Presentation -> Application -> Domain -> Infrastructure の方向で定義しており、
上の層が下の層を利用する、という一方通行の依存フローを定義して、
クラス同士の関係性により明瞭な方針を与えています。

MVC では、データに関する処理の部分が Model とのみ定義されており、
依存関係も、三角形の構造で複雑だったのに対し、
レイヤードアーキテクチャでは、Model 層が Domain と Infrastucture に分割されたのに加え、
依存の方向性も定義される等、より実践的なアプローチとなっています。

### オニオンアーキテクチャ

オニオンアーキテクチャでは、レイヤードアーキテクチャから発展して、以下のような依存の流れが定義されています。

- Presentation : UI に関するロジック ( 画面/Viewなど )
- Application : アプリケーション制御に関するロジック
- Domain Service : 機能仕様・業務知識に関する操作ロジック
- Domain Model : 機能・業務知識に関するデータロジック

Application が Infrastructure に依存せず、より抽象的な Domain Model に依存するようになります。

Infrastructure 層に関する処理は、以下のような形で依存関係逆転の原則により、
逆方向の依存関係で定義されるようになります。

- Infrastructure : DB や 外部APIなどデータストアに関するロジック
- Application : アプリケーション制御に関するロジック
- Domain Service : 機能仕様・業務知識に関する操作ロジック
- Domain Model : 機能・業務知識に関するデータロジック

上のような構造を図にすると玉ねぎ上のアーキテクチャ図ができるため、
オニオンアーキテクチャと呼ばれています。詳しくは以下の記事を参考にしてください。

https://qiita.com/little_hand_s/items/ebb4284afeea0e8cc752

## クラス設計の関心

様々な設計パターンを駆使してクラスを分割する上で、
忘れてはならないのが基本的なクラスの設計ルールです。

クラスの設計ルールとしては、 SOLID 原則やパッケージ原則などが知られますが、
以下に重要で理解しやすいもののみ説明しておきます。

### 単一責務の原則

クラスは、たった一つの責任のためにコードが記述されるべきという考え方を「単一責務の原則(SRP)」
クラスが全うすべき責任の範囲が明確化されていない場合、一つのクラスが様々なことを行ってしまい、
異なる用途で複数箇所からクラスが依存されてしまうなどの問題が生じます。

原則、クラスは一つの責任を全うすべきですし、万一クラスが複数の問題に対して
適用可能な状態となっている場合には、インターフェイスを用いて機能を分離(ISP:インターフェイス分離の原則)する事が望ましいでしょう。

古くからクラスの設計として SOLID 原則という考え方がよく参照されます。
SOLID 原則は以下の 5 つの考え方の頭文字をとったもので、一つ一つが柔軟なクラス設計を考える上での重要な指標になる考え方です。

- 単一責務の原則 Single Responsibility Principle (SRP)
- オープンクローズドの原則 Open Closed Principle (OCP)
- リスコフの置換原則 Liskov Substitution Principle (LSP)
- インターフェース分離の原則 Interface Segregation Principle (ISP)
- 依存性逆転の原則 Dependency Inversion Principle (DIP)

### ステートレスなクラス設計

クラスはプロパティを用いて、その内部に状態をもたせることが可能ですが、
クラス内部に用意された状態は、時として条件付きバグの温床になります。

クラス内プロパティが特定の値に書き換えられているケースでのみ A のメソドをコールすると例外が発生、
などと言ったバグは、原因検出も困難で障害調査のコストを大幅に増加させるでしょう。

この様な問題を回避するためには、クラスプロパティを利用せず、
単純なメソドのみを用いたクラス設計を行うのがベストです。

クラス内に用意された「状態」は一般的に「ステート」と呼ばれ、
クラス内に状態を持たないクラスを ステートレスなクラス、と呼びます。
